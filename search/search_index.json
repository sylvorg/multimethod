{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Multimethod provides a decorator for adding multiple argument dispatching to functions. The decorator creates a multimethod object as needed, and registers the function with its annotations.</p> <p>There are several multiple dispatch libraries on PyPI. This one aims for simplicity and speed. With caching of argument types, it should be the fastest pure Python implementation possible.</p>"},{"location":"#usage","title":"Usage","text":"<p>There are a couple options which trade-off dispatch speed for flexibility.</p> Decorator Speed Dispatch Arguments multimethod faster cached lookup positional only multidispatch slower binds to first signature + cached lookup positional + keywords <p>Dispatching on simple types which use <code>issubclass</code> is cached. Advanced types which use <code>isinstance</code> require a linear scan.</p>"},{"location":"#multimethod","title":"multimethod","text":"<pre><code>from multimethod import multimethod\n\n@multimethod\ndef func(x: int, y: float):\n    ...\n</code></pre> <p><code>func</code> is now a <code>multimethod</code> which will delegate to the above function, when called with arguments of the specified types. Subsequent usage will register new types and functions to the existing multimethod of the same name.</p> <pre><code>@multimethod\ndef func(x: float, y: int):\n    ...\n</code></pre> <p>Alternatively, functions can be explicitly registered in the same style as functools.singledispatch. This syntax is also compatible with mypy, which by default checks that each name is defined once.</p> <pre><code>@func.register\ndef _(x: bool, y: bool):\n    ...\n\n\n@func.register(object, bool)\n@func.register(bool, object)\ndef _(x, y):  # stackable without annotations\n    ...\n</code></pre> <p>Multimethods are implemented as mappings from signatures to functions, and can be introspected as such.</p> <pre><code>method[type, ...]           # get registered function\nmethod[type, ...] = func    # register function by explicit types\n</code></pre> <p>Multimethods support any types that satisfy the <code>issubclass</code> relation, including abstract base classes in <code>collections.abc</code> and <code>typing</code>. Subscripted generics are supported: * <code>Union[...]</code> or <code>... | ...</code> * <code>Mapping[...]</code> - the first key-value pair is checked * <code>tuple[...]</code> - all args are checked * <code>Iterable[...]</code> - the first arg is checked * <code>Type[...]</code> * <code>Literal[...]</code> * <code>Callable[[...], ...]</code> - parameter types are contravariant, return type is covariant</p> <p>Naturally checking subscripts is slower, but the implementation is optimized, cached, and bypassed if no subscripts are in use in the parameter. Empty iterables match any subscript, but don't special-case how the types are normally resolved.</p> <p>Dispatch resolution details: * If an exact match isn't registered, the next closest method is called (and cached). * If there are ambiguous methods - or none - a custom <code>TypeError</code> is raised. * Keyword-only parameters may be annotated, but won't affect dispatching. * A skipped annotation is equivalent to <code>: object</code>. * If no types are specified, it will inherently match all arguments.</p> <p><code>classmethod</code> and <code>staticmethod</code> may be used with a multimethod, but must be applied last, i.e., wrapping the final multimethod definition after all functions are registered. For class and instance methods, <code>cls</code> and <code>self</code> participate in the dispatch as usual. They may be left blank when using annotations, otherwise use <code>object</code> as a placeholder.</p> <pre><code>class Foo:\n    # @classmethod: only works here if there are no more functions\n    @multimethod\n    def bar(cls, x: str):\n        ...\n\n    # @classmethod: can not be used with `register` because `_` is not the multimethod\n    @bar.register\n    def _(cls, x: int):\n        ...\n\n    bar = classmethod(bar)  # done with registering\n</code></pre>"},{"location":"#multidispatch","title":"multidispatch","text":"<p><code>multidispatch</code> is a wrapper to provide compatibility with <code>functools.singledispatch</code>. It requires a base implementation and use of the <code>register</code> method instead of namespace lookup. It also supports dispatching on keyword arguments.</p>"},{"location":"#instance-checks","title":"instance checks","text":"<p><code>subtype</code> provisionally provides <code>isinstance</code> and <code>issubclass</code> checks for generic types. When called on a non-generic, it will return the origin type.</p> <pre><code>from multimethod import subtype\n\ncls = subtype(int | list[int])\n\nfor obj in (0, False, [0], [False], []):\n    assert isinstance(obj, cls)\nfor obj in (0.0, [0.0], (0,)):\n    assert not isinstance(obj, cls)\n\nfor subclass in (int, bool, list[int], list[bool]):\n    assert issubclass(subclass, cls)\nfor subclass in (float, list, list[float], tuple[int]):\n    assert not issubclass(subclass, cls)\n</code></pre> <p>If a type implements a custom <code>__instancecheck__</code>, it can opt-in to dispatch (without caching) by specifying <code>__orig_bases__</code> . <code>parametric</code> provides a convenient constructor, with support for predicate functions and checking attributes.</p> <pre><code>from multimethod import parametric\n\ncoro = parametric(Callable, asyncio.iscoroutinefunction)\nints = parametric(array, typecode='i')\n</code></pre> <p><code>overload</code> used to dispatch on annotated predicate functions. It is deprecated because a custom instance check - including using <code>parametric</code> - offers the same functionality.</p>"},{"location":"#multimeta","title":"multimeta","text":"<p>Use <code>metaclass=multimeta</code> to create a class with a special namespace which converts callables to multimethods, and registers duplicate callables with the original.</p> <pre><code>from multimethod import multimeta\n\nclass Foo(metaclass=multimeta):\n    def bar(self, x: str):\n        ...\n\n    def bar(self, x: int):\n        ...\n</code></pre> <p>Equivalent to:</p> <pre><code>from multimethod import multimethod\n\nclass Foo:\n    @multimethod\n    def bar(self, x: str):\n        ...\n\n    @bar.register\n    def bar(self, x: int):\n        ...\n</code></pre>"},{"location":"#installation","title":"Installation","text":"<pre><code>% pip install multimethod\n</code></pre>"},{"location":"#tests","title":"Tests","text":"<p>100% branch coverage.</p> <pre><code>% pytest [--cov]\n</code></pre>"},{"location":"examples/","title":"Examples","text":"In\u00a0[1]: Copied! <pre>from multimethod import multimethod\nimport operator\n\nclassic_div = multimethod(operator.truediv)\nclassic_div[int, int] = operator.floordiv\nclassic_div\n</pre> from multimethod import multimethod import operator  classic_div = multimethod(operator.truediv) classic_div[int, int] = operator.floordiv classic_div Out[1]: <pre>{(): &lt;function _operator.truediv(a, b, /)&gt;,\n (int, int): &lt;function _operator.floordiv(a, b, /)&gt;}</pre> In\u00a0[2]: Copied! <pre>classic_div(3, 2)\n</pre> classic_div(3, 2) Out[2]: <pre>1</pre> In\u00a0[3]: Copied! <pre>classic_div(3.0, 2)\n</pre> classic_div(3.0, 2) Out[3]: <pre>1.5</pre> In\u00a0[4]: Copied! <pre>classic_div\n</pre> classic_div Out[4]: <pre>{(): &lt;function _operator.truediv(a, b, /)&gt;,\n (int, int): &lt;function _operator.floordiv(a, b, /)&gt;,\n (float, int): &lt;function _operator.truediv(a, b, /)&gt;}</pre> <p>Multimethods introspect type annotations and use the name to find existing multimethods.</p> In\u00a0[5]: Copied! <pre>import itertools\nfrom collections.abc import Iterable, Sequence\n\n\n@multimethod\ndef chunks(values: Iterable, size):\n    it = iter(values)\n    return iter(lambda: list(itertools.islice(it, size)), [])\n\n\n@multimethod\ndef chunks(values: Sequence, size):\n    for index in range(0, len(values), size):\n        yield values[index : index + size]\n\n\nlist(chunks(iter('abcde'), 3))\n</pre> import itertools from collections.abc import Iterable, Sequence   @multimethod def chunks(values: Iterable, size):     it = iter(values)     return iter(lambda: list(itertools.islice(it, size)), [])   @multimethod def chunks(values: Sequence, size):     for index in range(0, len(values), size):         yield values[index : index + size]   list(chunks(iter('abcde'), 3)) Out[5]: <pre>[['a', 'b', 'c'], ['d', 'e']]</pre> In\u00a0[6]: Copied! <pre>list(chunks('abcde', 3))\n</pre> list(chunks('abcde', 3)) Out[6]: <pre>['abc', 'de']</pre> <p>Multimethods also have an explicit <code>register</code> method similar to <code>functools.singledispatch</code>.</p> In\u00a0[7]: Copied! <pre>@multimethod\ndef window(values, size=2):\n    its = itertools.tee(values, size)\n    return zip(*(itertools.islice(it, index, None) for index, it in enumerate(its)))\n\n\n@window.register\ndef _(values: Sequence, size=2):\n    for index in range(len(values) - size + 1):\n        yield values[index : index + size]\n\n\nlist(window(iter('abcde')))\n</pre> @multimethod def window(values, size=2):     its = itertools.tee(values, size)     return zip(*(itertools.islice(it, index, None) for index, it in enumerate(its)))   @window.register def _(values: Sequence, size=2):     for index in range(len(values) - size + 1):         yield values[index : index + size]   list(window(iter('abcde'))) Out[7]: <pre>[('a', 'b'), ('b', 'c'), ('c', 'd'), ('d', 'e')]</pre> In\u00a0[8]: Copied! <pre>list(window('abcde'))\n</pre> list(window('abcde')) Out[8]: <pre>['ab', 'bc', 'cd', 'de']</pre> In\u00a0[9]: Copied! <pre>import asyncio\nimport time\nfrom collections.abc import Callable\nfrom concurrent import futures\nfrom multimethod import parametric\n\ncoro = parametric(Callable, asyncio.iscoroutinefunction)\n\n\n@multimethod\ndef wait(timeout, func, *args):\n    return futures.ThreadPoolExecutor().submit(func, *args).result(timeout)\n\n\n@multimethod\nasync def wait(timeout, func: coro, *args):\n    return await asyncio.wait_for(func(*args), timeout)\n\n\nwait(0.5, time.sleep, 0.01)\n</pre> import asyncio import time from collections.abc import Callable from concurrent import futures from multimethod import parametric  coro = parametric(Callable, asyncio.iscoroutinefunction)   @multimethod def wait(timeout, func, *args):     return futures.ThreadPoolExecutor().submit(func, *args).result(timeout)   @multimethod async def wait(timeout, func: coro, *args):     return await asyncio.wait_for(func(*args), timeout)   wait(0.5, time.sleep, 0.01) In\u00a0[10]: Copied! <pre>wait(0.5, asyncio.sleep, 0.01)\n</pre> wait(0.5, asyncio.sleep, 0.01) Out[10]: <pre>&lt;coroutine object wait at 0x7f89c83e33e0&gt;</pre> In\u00a0[11]: Copied! <pre>import bisect\nimport random\n\n\n@multimethod\ndef samples(weights: dict):\n    \"\"\"Generate weighted random samples using bisection.\"\"\"\n    keys = list(weights)\n    totals = list(itertools.accumulate(weights.values()))\n    values = [total / totals[-1] for total in totals]\n    while True:\n        yield keys[bisect.bisect_right(values, random.random())]\n\n\n@multimethod\ndef samples(weights: dict[object, int]):\n    \"\"\"Generate weighted random samples more efficiently.\"\"\"\n    keys = list(itertools.chain.from_iterable([key] * weights[key] for key in weights))\n    while True:\n        yield random.choice(keys)\n\n\nweights = {'a': 1, 'b': 2, 'c': 3}\nnext(samples(weights))\n</pre> import bisect import random   @multimethod def samples(weights: dict):     \"\"\"Generate weighted random samples using bisection.\"\"\"     keys = list(weights)     totals = list(itertools.accumulate(weights.values()))     values = [total / totals[-1] for total in totals]     while True:         yield keys[bisect.bisect_right(values, random.random())]   @multimethod def samples(weights: dict[object, int]):     \"\"\"Generate weighted random samples more efficiently.\"\"\"     keys = list(itertools.chain.from_iterable([key] * weights[key] for key in weights))     while True:         yield random.choice(keys)   weights = {'a': 1, 'b': 2, 'c': 3} next(samples(weights)) Out[11]: <pre>'b'</pre> In\u00a0[12]: Copied! <pre>weights = {'a': 1.0, 'b': 2.0, 'c': 3.0}\nnext(samples(weights))\n</pre> weights = {'a': 1.0, 'b': 2.0, 'c': 3.0} next(samples(weights)) Out[12]: <pre>'c'</pre>"},{"location":"examples/#examples","title":"Examples\u00b6","text":""},{"location":"examples/#mutlimethod","title":"mutlimethod\u00b6","text":"<p>Multimethods are a mapping of signatures (tuple of types) to functions.  They maintain an efficient dispatch tree, and cache the called signatures.</p>"},{"location":"examples/#parametric","title":"parametric\u00b6","text":"<p>In addition to <code>issubclass</code>, multimethods can dispatch on <code>isinstance</code> with additional parametric checks.</p>"},{"location":"examples/#typing-subscripts","title":"typing subscripts\u00b6","text":"<p>Support for type hints with subscripts.</p>"},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#multimethod.multimethod","title":"<code>multimethod.multimethod</code>","text":"<p>             Bases: <code>dict</code></p> <p>A callable directed acyclic graph of methods.</p> Source code in <code>multimethod/__init__.py</code> <pre><code>class multimethod(dict):\n    \"\"\"A callable directed acyclic graph of methods.\"\"\"\n\n    __name__: str\n    pending: set\n    generics: list[tuple]  # positional bases which require instance checks\n\n    def __new__(cls, func):\n        homonym = inspect.currentframe().f_back.f_locals.get(func.__name__)\n        if isinstance(homonym, multimethod):\n            return homonym\n\n        self = functools.update_wrapper(dict.__new__(cls), func)\n        self.pending = set()\n        self.generics = []\n        return self\n\n    def __init__(self, func: Callable):\n        try:\n            self[signature.from_hints(func)] = func\n        except (NameError, AttributeError):\n            self.pending.add(func)\n\n    @tp_overload\n    def register(self, __func: REGISTERED) -&gt; REGISTERED: ...  # pragma: no cover\n\n    @tp_overload\n    def register(self, *args: type) -&gt; Callable[[REGISTERED], REGISTERED]: ...  # pragma: no cover\n\n    def register(self, *args) -&gt; Callable:\n        \"\"\"Decorator for registering a function.\n\n        Optionally call with types to return a decorator for unannotated functions.\n        \"\"\"\n        if len(args) == 1 and hasattr(args[0], '__annotations__'):\n            multimethod.__init__(self, *args)\n            return self if self.__name__ == args[0].__name__ else args[0]\n        return lambda func: self.__setitem__(args, func) or func\n\n    def __get__(self, instance, owner):\n        return self if instance is None else types.MethodType(self, instance)\n\n    def parents(self, types: tuple) -&gt; set:\n        \"\"\"Find immediate parents of potential key.\"\"\"\n        parents = {key for key in list(self) if isinstance(key, signature) and key &lt; types}\n        return parents - {ancestor for parent in parents for ancestor in parent.parents}\n\n    def clean(self):\n        \"\"\"Empty the cache.\"\"\"\n        for key in list(self):\n            if not isinstance(key, signature):\n                super().__delitem__(key)\n\n    def copy(self):\n        \"\"\"Return a new multimethod with the same methods.\"\"\"\n        return dict.__new__(type(self)).__ior__(self)\n\n    def __setitem__(self, types: tuple, func: Callable):\n        self.clean()\n        if not isinstance(types, signature):\n            types = signature(types)\n        parents = types.parents = self.parents(types)\n        with contextlib.suppress(ValueError):\n            types.sig = inspect.signature(func)\n        self.pop(types, None)  # ensure key is overwritten\n        for key in self:\n            if types &lt; key and (not parents or parents &amp; key.parents):\n                key.parents -= parents\n                key.parents.add(types)\n        for index, cls in enumerate(types):\n            if origins := set(subtype.origins(cls)):\n                self.generics += [()] * (index + 1 - len(self.generics))\n                self.generics[index] = tuple(origins.union(self.generics[index]))\n        super().__setitem__(types, func)\n        self.__doc__ = self.docstring\n\n    def __delitem__(self, types: tuple):\n        self.clean()\n        super().__delitem__(types)\n        for key in self:\n            if types in key.parents:\n                key.parents = self.parents(key)\n        self.__doc__ = self.docstring\n\n    def select(self, types: tuple, keys: set[signature]) -&gt; Callable:\n        keys = {key for key in keys if key.callable(*types)}\n        funcs = {self[key] for key in keys}\n        if len(funcs) &gt; 1:\n            groups = collections.defaultdict(set)\n            for key in keys:\n                groups[types - key].add(key)\n            keys = groups[min(groups)]\n            funcs = {self[key] for key in keys}\n            if len(funcs) == 1:\n                warnings.warn(\"positional distance tie-breaking is deprecated\", DeprecationWarning)\n        if len(funcs) == 1:\n            return funcs.pop()\n        raise DispatchError(f\"{self.__name__}: {len(keys)} methods found\", types, keys)\n\n    def __missing__(self, types: tuple) -&gt; Callable:\n        \"\"\"Find and cache the next applicable method of given types.\"\"\"\n        self.evaluate()\n        types = tuple(map(subtype, types))\n        if types in self:\n            return self[types]\n        return self.setdefault(types, self.select(types, self.parents(types)))\n\n    def dispatch(self, *args) -&gt; Callable:\n        types = tuple(map(type, args))\n        if not any(map(issubclass, types, self.generics)):\n            return self[types]\n        matches = {key for key in list(self) if isinstance(key, signature) and key.instances(*args)}\n        matches -= {ancestor for match in matches for ancestor in match.parents}\n        return self.select(types, matches)\n\n    def __call__(self, *args, **kwargs):\n        \"\"\"Resolve and dispatch to best method.\"\"\"\n        self.evaluate()\n        func = self.dispatch(*args)\n        try:\n            return func(*args, **kwargs)\n        except TypeError as ex:\n            raise DispatchError(f\"Function {func.__code__}\") from ex\n\n    def evaluate(self):\n        \"\"\"Evaluate any pending forward references.\"\"\"\n        while self.pending:\n            func = self.pending.pop()\n            self[signature.from_hints(func)] = func\n\n    @property\n    def docstring(self):\n        \"\"\"a descriptive docstring of all registered functions\"\"\"\n        docs = []\n        for key, func in self.items():\n            sig = getattr(key, 'sig', '')\n            if func.__doc__:\n                docs.append(f'{func.__name__}{sig}\\n    {func.__doc__}')\n        return '\\n\\n'.join(docs)\n</code></pre>"},{"location":"reference/#multimethod.multimethod.docstring","title":"<code>docstring</code>  <code>property</code>","text":"<p>a descriptive docstring of all registered functions</p>"},{"location":"reference/#multimethod.multimethod.__call__","title":"<code>__call__(*args, **kwargs)</code>","text":"<p>Resolve and dispatch to best method.</p> Source code in <code>multimethod/__init__.py</code> <pre><code>def __call__(self, *args, **kwargs):\n    \"\"\"Resolve and dispatch to best method.\"\"\"\n    self.evaluate()\n    func = self.dispatch(*args)\n    try:\n        return func(*args, **kwargs)\n    except TypeError as ex:\n        raise DispatchError(f\"Function {func.__code__}\") from ex\n</code></pre>"},{"location":"reference/#multimethod.multimethod.__missing__","title":"<code>__missing__(types)</code>","text":"<p>Find and cache the next applicable method of given types.</p> Source code in <code>multimethod/__init__.py</code> <pre><code>def __missing__(self, types: tuple) -&gt; Callable:\n    \"\"\"Find and cache the next applicable method of given types.\"\"\"\n    self.evaluate()\n    types = tuple(map(subtype, types))\n    if types in self:\n        return self[types]\n    return self.setdefault(types, self.select(types, self.parents(types)))\n</code></pre>"},{"location":"reference/#multimethod.multimethod.clean","title":"<code>clean()</code>","text":"<p>Empty the cache.</p> Source code in <code>multimethod/__init__.py</code> <pre><code>def clean(self):\n    \"\"\"Empty the cache.\"\"\"\n    for key in list(self):\n        if not isinstance(key, signature):\n            super().__delitem__(key)\n</code></pre>"},{"location":"reference/#multimethod.multimethod.copy","title":"<code>copy()</code>","text":"<p>Return a new multimethod with the same methods.</p> Source code in <code>multimethod/__init__.py</code> <pre><code>def copy(self):\n    \"\"\"Return a new multimethod with the same methods.\"\"\"\n    return dict.__new__(type(self)).__ior__(self)\n</code></pre>"},{"location":"reference/#multimethod.multimethod.evaluate","title":"<code>evaluate()</code>","text":"<p>Evaluate any pending forward references.</p> Source code in <code>multimethod/__init__.py</code> <pre><code>def evaluate(self):\n    \"\"\"Evaluate any pending forward references.\"\"\"\n    while self.pending:\n        func = self.pending.pop()\n        self[signature.from_hints(func)] = func\n</code></pre>"},{"location":"reference/#multimethod.multimethod.parents","title":"<code>parents(types)</code>","text":"<p>Find immediate parents of potential key.</p> Source code in <code>multimethod/__init__.py</code> <pre><code>def parents(self, types: tuple) -&gt; set:\n    \"\"\"Find immediate parents of potential key.\"\"\"\n    parents = {key for key in list(self) if isinstance(key, signature) and key &lt; types}\n    return parents - {ancestor for parent in parents for ancestor in parent.parents}\n</code></pre>"},{"location":"reference/#multimethod.multimethod.register","title":"<code>register(*args)</code>","text":"<p>Decorator for registering a function.</p> <p>Optionally call with types to return a decorator for unannotated functions.</p> Source code in <code>multimethod/__init__.py</code> <pre><code>def register(self, *args) -&gt; Callable:\n    \"\"\"Decorator for registering a function.\n\n    Optionally call with types to return a decorator for unannotated functions.\n    \"\"\"\n    if len(args) == 1 and hasattr(args[0], '__annotations__'):\n        multimethod.__init__(self, *args)\n        return self if self.__name__ == args[0].__name__ else args[0]\n    return lambda func: self.__setitem__(args, func) or func\n</code></pre>"},{"location":"reference/#multimethod.multidispatch","title":"<code>multimethod.multidispatch</code>","text":"<p>             Bases: <code>multimethod</code>, <code>dict[tuple[type, ...], Callable[..., RETURN]]</code></p> <p>Wrapper for compatibility with <code>functools.singledispatch</code>.</p> <p>Only uses the register method instead of namespace lookup. Allows dispatching on keyword arguments based on the first function signature.</p> Source code in <code>multimethod/__init__.py</code> <pre><code>class multidispatch(multimethod, dict[tuple[type, ...], Callable[..., RETURN]]):\n    \"\"\"Wrapper for compatibility with `functools.singledispatch`.\n\n    Only uses the [register][multimethod.multimethod.register] method instead of namespace lookup.\n    Allows dispatching on keyword arguments based on the first function signature.\n    \"\"\"\n\n    signature: Optional[inspect.Signature]\n\n    def __new__(cls, func: Callable[..., RETURN]) -&gt; \"multidispatch[RETURN]\":\n        return functools.update_wrapper(dict.__new__(cls), func)\n\n    def __init__(self, func: Callable[..., RETURN]) -&gt; None:\n        self.pending = set()\n        self.generics = []\n        try:\n            self.signature = inspect.signature(func)\n        except ValueError:\n            self.signature = None\n        msg = \"base implementation will eventually ignore annotations as `singledispatch does`\"\n        with contextlib.suppress(NameError, AttributeError, TypeError):\n            hints = signature.from_hints(func)\n            if hints and all(map(issubclass, hints, hints)):\n                warnings.warn(msg, DeprecationWarning)\n        super().__init__(func)\n\n    def __get__(self, instance, owner) -&gt; Callable[..., RETURN]:\n        return self if instance is None else types.MethodType(self, instance)  # type: ignore\n\n    def __call__(self, *args: Any, **kwargs: Any) -&gt; RETURN:\n        \"\"\"Resolve and dispatch to best method.\"\"\"\n        params = self.signature.bind(*args, **kwargs).args if (kwargs and self.signature) else args\n        func = self.dispatch(*params)\n        return func(*args, **kwargs)\n</code></pre>"},{"location":"reference/#multimethod.multidispatch.__call__","title":"<code>__call__(*args, **kwargs)</code>","text":"<p>Resolve and dispatch to best method.</p> Source code in <code>multimethod/__init__.py</code> <pre><code>def __call__(self, *args: Any, **kwargs: Any) -&gt; RETURN:\n    \"\"\"Resolve and dispatch to best method.\"\"\"\n    params = self.signature.bind(*args, **kwargs).args if (kwargs and self.signature) else args\n    func = self.dispatch(*params)\n    return func(*args, **kwargs)\n</code></pre>"},{"location":"reference/#multimethod.subtype","title":"<code>multimethod.subtype</code>","text":"<p>             Bases: <code>ABCMeta</code></p> <p>A normalized generic type which checks subscripts.</p> <p>Transforms a generic alias into a concrete type which supports <code>issubclass</code> and <code>isinstance</code>. If the type ends up being equivalent to a builtin, the builtin is returned.</p> Source code in <code>multimethod/__init__.py</code> <pre><code>class subtype(abc.ABCMeta):\n    \"\"\"A normalized generic type which checks subscripts.\n\n    Transforms a generic alias into a concrete type which supports `issubclass` and `isinstance`.\n    If the type ends up being equivalent to a builtin, the builtin is returned.\n    \"\"\"\n\n    __origin__: type\n    __args__: tuple\n\n    def __new__(cls, tp, *args):\n        if tp is Any:\n            return object\n        if hasattr(tp, '__supertype__'):  # isinstance(..., NewType) only supported &gt;=3.10\n            tp = tp.__supertype__\n        if isinstance(tp, TypeVar):\n            if not tp.__constraints__:\n                return object\n            tp = Union[tp.__constraints__]\n        origin = get_origin(tp) or tp\n        if hasattr(types, 'UnionType') and isinstance(tp, types.UnionType):\n            origin = Union  # `|` syntax added in 3.10\n        args = tuple(map(cls, get_args(tp) or args))\n        if set(args) &lt;= {object} and not (origin is tuple and args):\n            return origin\n        bases = (origin,) if type(origin) in (type, abc.ABCMeta) else ()\n        if origin is Literal:\n            bases = (subtype(Union[tuple(map(type, args))]),)\n        if origin is Union:\n            counts = collections.Counter()\n            for arg in args:\n                counts.update(cls for cls in get_mro(arg) if issubclass(abc.ABCMeta, type(cls)))\n            bases = tuple(cls for cls in counts if counts[cls] == len(args))[:1]\n        if origin is Callable and args[:1] == (...,):\n            args = args[1:]\n        namespace = {'__origin__': origin, '__args__': args}\n        return type.__new__(cls, str(tp), bases, namespace)\n\n    def __init__(self, tp, *args): ...\n\n    def key(self) -&gt; tuple:\n        return self.__origin__, *self.__args__\n\n    def __eq__(self, other) -&gt; bool:\n        return hasattr(other, '__origin__') and self.key() == subtype.key(other)\n\n    def __hash__(self) -&gt; int:\n        return hash(self.key())\n\n    def __subclasscheck__(self, subclass):\n        origin = get_origin(subclass) or subclass\n        args = get_args(subclass)\n        if origin is Literal:\n            return all(isinstance(arg, self) for arg in args)\n        if origin is Union:\n            return all(issubclass(cls, self) for cls in args)\n        if self.__origin__ is Literal:\n            return False\n        if self.__origin__ is Union:\n            return issubclass(subclass, self.__args__)\n        if self.__origin__ is Callable:\n            return (\n                origin is Callable\n                and signature(self.__args__[-1:]) &lt;= signature(args[-1:])  # covariant return\n                and signature(args[:-1]) &lt;= signature(self.__args__[:-1])  # contravariant args\n            )\n        return (  # check args first to avoid recursion error: python/cpython#73407\n            len(args) == len(self.__args__)\n            and issubclass(origin, self.__origin__)\n            and all(pair[0] is pair[1] or issubclass(*pair) for pair in zip(args, self.__args__))\n        )\n\n    def __instancecheck__(self, instance):\n        if self.__origin__ is Literal:\n            return any(type(arg) == type(instance) and arg == instance for arg in self.__args__)\n        if self.__origin__ is Union:\n            return isinstance(instance, self.__args__)\n        if hasattr(instance, '__orig_class__'):  # user-defined generic type\n            return issubclass(instance.__orig_class__, self)\n        if self.__origin__ is type:  # a class argument is expected\n            return inspect.isclass(instance) and issubclass(instance, self.__args__)\n        if not isinstance(instance, self.__origin__) or isinstance(instance, Iterator):\n            return False\n        if self.__origin__ is Callable:\n            return issubclass(subtype(Callable, *get_type_hints(instance).values()), self)\n        if self.__origin__ is tuple and self.__args__[-1:] != (...,):\n            if len(instance) != len(self.__args__):\n                return False\n        elif issubclass(self, Mapping):\n            instance = next(iter(instance.items()), ())\n        else:\n            instance = itertools.islice(instance, 1)\n        return all(map(isinstance, instance, self.__args__))\n\n    def origins(self) -&gt; Iterator[type]:\n        \"\"\"Generate origins which would need subscript checking.\"\"\"\n        origin = get_origin(self)\n        if origin is Literal:\n            yield from set(map(type, self.__args__))\n        elif origin is Union:\n            for arg in self.__args__:\n                yield from subtype.origins(arg)\n        elif origin is not None:\n            yield origin\n        elif isinstance(self.__instancecheck__, types.MethodType):\n            yield from getattr(self, '__orig_bases__', ())\n</code></pre>"},{"location":"reference/#multimethod.subtype.origins","title":"<code>origins()</code>","text":"<p>Generate origins which would need subscript checking.</p> Source code in <code>multimethod/__init__.py</code> <pre><code>def origins(self) -&gt; Iterator[type]:\n    \"\"\"Generate origins which would need subscript checking.\"\"\"\n    origin = get_origin(self)\n    if origin is Literal:\n        yield from set(map(type, self.__args__))\n    elif origin is Union:\n        for arg in self.__args__:\n            yield from subtype.origins(arg)\n    elif origin is not None:\n        yield origin\n    elif isinstance(self.__instancecheck__, types.MethodType):\n        yield from getattr(self, '__orig_bases__', ())\n</code></pre>"},{"location":"reference/#multimethod.parametric","title":"<code>multimethod.parametric</code>","text":"<p>             Bases: <code>ABCMeta</code></p> <p>A type which further customizes <code>issubclass</code> and <code>isinstance</code> beyond the base type.</p> <p>Parameters:</p> Name Type Description Default <code>base</code> <p>base type</p> required <code>funcs</code> <p>all predicate functions are checked against the instance</p> required <code>attrs</code> <p>all attributes are checked for equality</p> required Source code in <code>multimethod/__init__.py</code> <pre><code>class parametric(abc.ABCMeta):\n    \"\"\"A type which further customizes `issubclass` and `isinstance` beyond the base type.\n\n    Args:\n        base: base type\n        funcs: all predicate functions are checked against the instance\n        attrs: all attributes are checked for equality\n    \"\"\"\n\n    def __new__(cls, base: type, *funcs: Callable, **attrs):\n        return super().__new__(cls, base.__name__, (base,), {'funcs': funcs, 'attrs': attrs})\n\n    def __init__(self, *_, **__):\n        self.__orig_bases__ = self.__bases__\n\n    def __subclasscheck__(self, subclass):\n        missing = object()\n        attrs = getattr(subclass, 'attrs', {})\n        return (\n            set(subclass.__bases__).issuperset(self.__bases__)  # python/cpython#73407\n            and set(getattr(subclass, 'funcs', ())).issuperset(self.funcs)\n            and all(attrs.get(name, missing) == self.attrs[name] for name in self.attrs)\n        )\n\n    def __instancecheck__(self, instance):\n        missing = object()\n        return (\n            isinstance(instance, self.__bases__)\n            and all(func(instance) for func in self.funcs)\n            and all(getattr(instance, name, missing) == self.attrs[name] for name in self.attrs)\n        )\n\n    def __and__(self, other):\n        (base,) = set(self.__bases__ + other.__bases__)\n        return type(self)(base, *set(self.funcs + other.funcs), **(self.attrs | other.attrs))\n</code></pre>"},{"location":"reference/#multimethod.DispatchError","title":"<code>multimethod.DispatchError</code>","text":"<p>             Bases: <code>TypeError</code></p> Source code in <code>multimethod/__init__.py</code> <pre><code>class DispatchError(TypeError):\n    pass\n</code></pre>"}]}